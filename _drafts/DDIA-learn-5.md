---
layout: post
title: DDIA Learning - 5
categories: [Book, Learn]
description: 数据密集型应用 - 读书笔记
keywords: Architecture, Learn
---

# 第五章 - 数据复制

复制主要指通过互联网络在多台机器上保存想通数据的副本，通过数据复制方案人们通常希望达到以下目的：

- 使数据在地理位置上更接近用户，从而降低访问延迟
- 当部分组件出现故障，系统依然可以继续工作，从而提高可用性
- 扩展至多台机器以同时提供数据访问服务，从而提高吞吐量

## 主节点与从节点

对于每笔数据写入，所有副本都需要随之更新：否则， 某些副本将出现不一致。最常见的解决方案是基于主节点的复制（也称为主动／被动，或主从复制）

1. 指定某一个副本为主副本 （或称为主节点） 。当客户写数据库时，必须将写请求首先发送给主副本，主副本首先将新数据写入本地存储。
2. 其他副本则全部称为从副本（或称为从节点）注 。主副本把新数据写入本地存储后，然后将数据更改作为复制的日志或更改流发送给所有从副本。每个从副本获得更改日志之后将其应用到本地，且严格保持与主副本相同的写入顺序。
3. 客户端从数据库中读数据 ，可以在主副本或者从副本上执行查询。再次强调，只有主副本才可以接受写请求 ：从客户端的角度来看，从副本都是只读的。

### 同步复制与异步复制

**区别**

- 同步复制中，主节点需要等待从节点确认完成了写入，之后才会进行后续处理（如发送 response 向用户报告完成）
- 异步复制中，主节点向从节点发送复制消息之后立即返回，不用等待从节点的完成确认

可以看到，异步复制可能会存在延迟，从而导致某些从节点的数据和主节点的数据不一致。有些情况下，从节点可能落后主节点几分钟甚至更长时间，例如，由于从节点刚从故障中恢复，或者系统已经接近最大设计上限，或者节点之间的网络出现问题

**同步复制优缺点**

- 优点：一旦向用户确认，从节点可以明确保证完成了与主节点的更新同步，数据已经处于最新版本。万一主节点发生故障，总是可以在从节点继续访问最新数据。
- 缺点：如果同步的从节点无法完成确认（例如由于从节点发生崩愤，或者网络故障，或任何其他原因），写入就不能视为成功。主节点会阻塞其后所有的操作，直到同步副本确认完成

**实践**

- 半同步复制：如果数据库启用了同步复制，通常意味着其中某一个从节点是同步的，而其他节点则是异步模式。万一同步的从节点变得不可用或性能下降，则将另一个异步的从节点提升为同步模式。这样可以保证至少有两个节点（即主节点和一个同步从节点）拥有最新的数据副本。这种配置有时也称为半同步
- 全异步复制：此时如果主节点发生失败且不可恢复，则有尚未复制到从节点的写请求都会丢失。这意味着即使向客户端确认了写操作，却无法保证数据的持久化。但全异步配置的优点则是，不管从节点上数据多么滞后，主节点总是可以继续响应写请求，系统的吞吐性能更好

### 配置新的从节点

常见的做法是使用主节点某一时刻数据副本的快照 (snapshot) 进行复制，主要操作步骤为：

1. 在某个时间点对主节点的数据副本产生一个一致性快照，这样避免长时间锁定整个数据库。目前大多数数据库都支持此功能，快照也是系统备份所必需的。而在某些情况下，可能需要第三方工具
2. 将此快照拷贝到新的从节点
3. 从节点连接到主节点并请求快照点之后所发生的数据更改日志。因为在第一步建快照时，快照与系统复制日志的某个确定位置相关联，这个位置信息在不同的系统有不同的称乎
4. 获得日志之后，从节点来应用这些快照点之后所有数据变更，这个过程称之为追赶。接下来，它可以继 处理主节点上新的数据变化。井重复这四个步骤

### 处理节点失效

**从节点失效：追赶式修复**

从节点的本地磁盘上都保存了副本收到的数据变更日志，如果从节点发生崩溃，则根据副本的复制日志，从节点就可以知道在发生故障之前锁所处理的最后一笔事务，然后连接到主节点，请求自那笔事务之后中断期间内所有的数据变更并应用到本地来追赶主节点即可。

**主节点失效：节点切换**

首先我们要确认主节点真正失效（一般基于超时机制），一经确认，我们就需要重新进行主节点选举，并通知客户端向新的主节点发送写请求。可能存在的问题如下，对于这些问题并没有简单的解决方案：

- 如果使用了异步复制且失效前新的主节点并未收到原主节点的所有数据，在选举之后原主节点又很快上线，那么新的主节点可能会收到冲突的写请求，这是因为原主节点并未意识到角色的变化。常见的解决方案是丢弃原主节点上未完成复制的写请求。
- 如果在数据库之外有其他系统依赖于数据库的内容并在一起协同使用，丢弃数据的方案就会非常危险
- 可能会存在脑裂（split-brain）问题，即两个节点同时都认为自己是主节点。它非常危险，两个节点都可能接受写请求，并且没有很好的解决冲突办法。一种安全应急方案是采取措施强制关闭其中一个节点。
- 设置合适的超时来检测主节点失效也是一个 Tradeoff

### 复制日志的实现

**基于语句的复制**

最简单的情况，主节点记录所执行的每个写请求（操作语句）并将该操作语句作为日志发送给从节点，看似简单但有一些不适用的场景：

- 任何调用非确定性函数的语句，如 NOW 获取当前时间，或 RAND 获取一个随机数等，可能会在不同的副本上产生不同的值。
- 如果语句中使用了自增列，或者依赖于数据库的现有数据（例如，UPDATE WHERE ＜某些条件＞），则所有副本必须按照完全相同的顺序执行，否则可能会带来不同的结果。进而，如果有多个同时并发执行 事务时，会有很大的限制
- 有副作用的语句（例如，触发器、存储过程、用户定义的函数等），可能会在每个副本上产生不同的副作用

有可能采取一些特殊措施来解决这些问题，但由于要考虑的情况太多，因此目前通常首选其他方案。

**基于预写日志（WAL）传输**

所有对数据库写入的字节序列都会被记入日志，因此可以使用完全相同的日志在另一个节点上构建副本。其主要缺点是日志描述的数据结果非常底 WAL 包含了哪些磁盘块的哪些字节发生改变，诸如此类的细节。这使得复制方案和存储引擎紧密搞合。如果数据库的存储格式从一个版本改为个版本，那么系统通常无法支持主从节点上运行不同版本的软件。

**基于行的逻辑日志复制**

复制和存储引擎采用不同的日志格式，这样复制与存储逻辑剥离。这种复制日志成为逻辑日志，以区分物理存储引擎的数据表示。

关系数据库的逻辑日志通常是指一系列记录来描述数据表行级别的写请求：

- 对于行插入，日志包含所有相关列的新值。
- 对于行删除，日志里有足够的信息来唯一标识已删除的行，通常是靠主键，但如果表上没有定义主键，就需要记录所有列的旧值。
- 对于行更新，日志包含足够的信息来唯一标识更新的行，以及所有列的新值（或至少包含所有已更新列的新值）。

如果一条事务涉及多行的修改，则会产生多个这样的日志记录，并在后面跟着一条记录，指出该事务已经提交。

**基于触发器的复制**

触发器支持注册自己的应用层代码，使得当数据库系统发生数据更改（写事务）时自动执行上述自定义代码。通过触发器技术，可以将数据更改记录到一个单独的表中，然后外部处理逻辑访问该表，实施必要的自定义应用层逻辑，例如将数据更改复制到另一个系统。
