<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>RabbitMQ 学习笔记 - 高级篇 &mdash; Wu</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/226wyj/226wyj.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/226wyj/226wyj.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/226wyj/226wyj.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/226wyj/226wyj.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/226wyj/226wyj.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/226wyj/226wyj.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/226wyj/226wyj.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/226wyj/226wyj.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/226wyj/226wyj.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="canonical" href="https://226wyj.github.io/2024/01/04/RabbitMQ-learn-advance/"><link rel="alternate" type="application/atom+xml" title="Wu" href="https://226wyj.github.io/feed.xml"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/226wyj/226wyj.github.io@master/favicon.ico"><meta property="og:title" content="RabbitMQ 学习笔记 - 高级篇"><meta name="keywords" content="RabbitMQ, Learn"><meta name="og:keywords" content="RabbitMQ, Learn"><meta name="description" content=" 课程链接：bilibiliP16 - P31"><meta name="og:description" content=" 课程链接：bilibiliP16 - P31"><meta property="og:url" content="https://226wyj.github.io/2024/01/04/RabbitMQ-learn-advance/"><meta property="og:site_name" content="Wu"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2024-01-04"> <script src="https://cdn.jsdelivr.net/gh/226wyj/226wyj.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/226wyj/226wyj.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/226wyj/226wyj.github.io@master/assets/js/main.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://226wyj.github.io/" title="Wu"><span class="octicon octicon-mark-github"></span> Wu</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://226wyj.github.io/" class=" site-header-nav-item" target="" title="Home">Home</a> <a href="https://226wyj.github.io/categories/" class=" site-header-nav-item" target="" title="Categories">Categories</a> <a href="https://226wyj.github.io/wiki/" class=" site-header-nav-item" target="" title="Wiki">Wiki</a> <a href="https://226wyj.github.io/links/" class=" site-header-nav-item" target="" title="Link">Link</a> <a href="https://226wyj.github.io/about/" class=" site-header-nav-item" target="" title="About">About</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="RabbitMQ 学习笔记 -"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">RabbitMQ 学习笔记 - 高级篇</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2024/01/04 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://226wyj.github.io/categories/#Learn" title="Learn">Learn</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 2770 字，约 8 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><blockquote><p>课程链接：<a href="https://www.bilibili.com/video/BV1mN4y1Z7t9/?vd_source=734a4a3d12292363fc3078169ddd7db2">bilibili</a> P16 - P31</p></blockquote><h2 id="发送者的可靠性">发送者的可靠性</h2><p><strong>生产者重连</strong></p><p><a href="/images/blog/rabbitmq/advance/producer-retry.png"></a></p><p><strong>生产者确认</strong></p><p><a href="/images/blog/rabbitmq/advance/producer-confirm.png"></a></p><p>如何处理生产者的确认消息？</p><ul><li>尽管有四种情况，但我们真正需要处理的只有 NACK 这一种，即消息 publish 失败</li><li>生产者确认需要额外的网络和系统资源开销，尽量不要使用，如果一定要使用则无需开启 <code class="language-plaintext highlighter-rouge">Publisher-Return</code> 机制，只开启 <code class="language-plaintext highlighter-rouge">Publisher-Confirm</code> 即可，因为一般路由失败是代码问题</li><li>对于 nack 消息可以有限次数重试，依然失败则记录异常信息</li></ul><h2 id="mq-的可靠性">MQ 的可靠性</h2><p>默认情况下 RabbitMQ 会把消息存放在内存中，尽管效率高但会有两个问题：</p><ul><li>一旦 MQ 宕机，内存中的消息会消失</li><li>内存空间有限，当消费者故障或处理过慢时，会导致消息积压，引发 MQ 阻塞</li></ul><h3 id="数据持久化">数据持久化</h3><p>可以通过配置让交换机、队列、以及发送的消息都持久化，这样队列中的消息会持久化到磁盘，MQ 重启消息依然存在</p><h3 id="lazy-queue">Lazy Queue</h3><p>惰性队列，接收到消息后直接存入磁盘而非内存（内存中只保留最近消息，默认 2048 条），消费者要消费消息时才会从磁盘中读取加载到内存，可以支持数百万条的消息存储</p><p>要设置一个队列为 Lazy Queue，只需要在声明队列时指定 <code class="language-plaintext highlighter-rouge">x-queue-mode</code> 为 lazy 即可</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 直接创建 Queue 对象</span>
<span class="nd">@Bean</span>
<span class="kd">public</span> <span class="nc">Queue</span> <span class="nf">lazyQueue</span><span class="o">()</span> <span class="o">{</span>
   <span class="k">return</span> <span class="nc">QueueBuilder</span>
            <span class="o">.</span><span class="na">durable</span><span class="o">(</span><span class="s">"lazy.queue"</span><span class="o">)</span>
            <span class="o">.</span><span class="na">lazy</span><span class="o">()</span> <span class="c1">// 开启 lazy 模式</span>
            <span class="o">.</span><span class="na">build</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// 基于 @RabbitListener 注解创建 Queue</span>
<span class="nd">@RabbitListener</span><span class="o">(</span><span class="n">queuesToDeclare</span> <span class="o">=</span> <span class="nd">@Queue</span><span class="o">(</span>
   <span class="n">name</span> <span class="o">=</span> <span class="s">"lazy.queue"</span><span class="o">,</span>
   <span class="n">durable</span> <span class="o">=</span> <span class="s">"true"</span><span class="o">,</span>
   <span class="n">arguments</span> <span class="o">=</span> <span class="nd">@Argument</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"x-queue-mode"</span><span class="o">,</span> <span class="n">value</span> <span class="o">=</span> <span class="s">"lazy"</span><span class="o">)</span>
<span class="o">))</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">listenLazyQueue</span><span class="o">(</span><span class="nc">String</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
   <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"接收到 lazy.queue 的消息: {}"</span><span class="o">,</span> <span class="n">msg</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><h2 id="消费者的可靠性">消费者的可靠性</h2><h3 id="消费者确认机制">消费者确认机制</h3><p>为了确认消费者是否成功处理消息，RabbitMQ 提供了消费者确认机制（Consumer Acknowledgement），当消费者处理消息结束后应该向 RabbitMQ 发送一个回执，有三种值：</p><ul><li>ack：成功处理消息，MQ 从队列中删除消息</li><li>nack：消息处理失败，MQ 需要再次投递消息</li><li>reject：消息处理失败并拒绝该消息，MQ 从队列中删除消息</li></ul><p>什么时候会 reject：消息本身是有问题的，consumer 处理的时候会报错</p><p><a href="/images/blog/rabbitmq/advance/consumer-ack.png"></a></p><div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">spring</span><span class="pi">:</span>
  <span class="na">rabbitmq</span><span class="pi">:</span>
    <span class="na">listener</span><span class="pi">:</span>
      <span class="na">simple</span><span class="pi">:</span>
        <span class="na">prefetch</span><span class="pi">:</span> <span class="m">1</span>
          <span class="na">acknoledge-mode</span><span class="pi">:</span> <span class="s">none</span> <span class="c1"># none, 关闭 ack; manual, 手动 ack; auto: 自动 ack</span>
</code></pre></div></div><p>我们把 ack mode 设置成 <code class="language-plaintext highlighter-rouge">auto</code> 之后会使可靠性大大增强，只有消费者处理成功之后消息才会被移除，否则消息会被重新投递</p><h3 id="消费失败处理">消费失败处理</h3><p>如果我们只是把 ack mode 设置成 auto 就不管了，那么消费者出现异常后，消息会不断 requeue 到队列，再重新发送给消费者，然后再次出现异常，从而无限循环。我们可以使用 Spring 的 retry 机制，在消费者出现异常时利用本地重试，而不是无限制 requeue 到 mq 队列</p><div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">spring</span><span class="pi">:</span>
  <span class="na">rabbitmq</span><span class="pi">:</span>
    <span class="na">listener</span><span class="pi">:</span>
      <span class="na">simple</span><span class="pi">:</span>
        <span class="na">prefetch</span><span class="pi">:</span> <span class="m">1</span>
          <span class="na">retry</span><span class="pi">:</span>
            <span class="na">enabled</span><span class="pi">:</span> <span class="no">true</span> <span class="c1"># 开启本地重试</span>
            <span class="na">initial-interval</span><span class="pi">:</span> <span class="s">1000ms</span> <span class="c1"># 初始的失败等待时长为 1s</span>
            <span class="na">multiplier</span><span class="pi">:</span> <span class="m">1</span> <span class="c1"># 下次失败的等待时长倍数，下次等待时长 = multiplier * (last-interval)</span>
            <span class="na">max-attempts</span><span class="pi">:</span> <span class="m">3</span> <span class="c1"># 最大重试次数</span>
            <span class="na">stateless</span><span class="pi">:</span> <span class="no">true</span> <span class="c1"># true 无状态 false 有状态，如果业务中包含事务使用 false</span>
</code></pre></div></div><p>重试多次依旧失败则需要有 <code class="language-plaintext highlighter-rouge">MessageRecoverer</code> 接口来处理</p><ul><li>RejectAndDontRequeueRecoverer: 重试耗尽后直接 reject，默认就是这种方式</li><li>ImmediateRequeueMessageRecoverer: 重试耗尽后返回 nack，消息重新入队</li><li>RepublishMessageRecoverer: 重试耗尽后将失败消息投递到指定的交换机</li></ul><h3 id="业务幂等性">业务幂等性</h3><p>即业务多次重复处理的结果和只处理一次的结果是相同的</p><h4 id="方案一唯一消息-id">方案一：唯一消息 id</h4><ul><li>给每个消息都设置一个唯一的 id，与消息一起投递给消费者</li><li>消费者收到消息后处理自己的业务，业务处理成功后将消息 id 保存到数据库</li><li>如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息放弃处理</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Bean</span>
<span class="kd">public</span> <span class="nc">MessageConverter</span> <span class="nf">messageConverter</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 1. 定义消息转换器</span>
    <span class="nc">Jackson2JsonMessageConverter</span> <span class="n">jjmc</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Jackson2JsonMessageConverter</span><span class="o">();</span>
    <span class="c1">// 2. 配置自动创建消息 id，用于识别不同消息，也可以在业务中基于 id 判断是否是重复消息</span>
    <span class="n">jjmc</span><span class="o">.</span><span class="na">setCreateMessageIds</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">jjmc</span>
<span class="o">}</span>
</code></pre></div></div><p>缺点：对原有业务有侵入，并且增加了写数据库步骤，性能会有影响</p><h4 id="方案二业务判断">方案二：业务判断</h4><p>结合业务逻辑，基于业务本身做判断</p><p><a href="/images/blog/rabbitmq/advance/idempotence.png"></a></p><h2 id="延迟消息">延迟消息</h2><ul><li>延迟消息：生产者发送消息时指定一个时间，消费者不会立刻收到消息，而是在指定时间之后才收到消息</li><li>延迟任务：设置在一定时间之后才执行的任务</li></ul><p>应用场景：订单支付倒计时</p><h3 id="死信交换机">死信交换机</h3><p>当一个队列中的消息满足下面条件之一时就是死信（dead letter）：</p><ul><li>消费者使用 basic.reject 或 basic.nack 声明消费失败，并且消息的 requeue 参数设置为 false</li><li>消息时一个过期的消息（达到了队列或消息本身设置的过期时间），超时无人消费</li><li>要投递的队列消息堆积满了，最早的消息可能成为死信</li></ul><p>如果队列通过 dead-letter-exchange 属性指定了一个交换机，那么该队列中的死信就会投递到这个交换机中，这个交换机被称为死信交换机（Dead letter exchange，简称 DLX）</p><h3 id="延迟消息插件">延迟消息插件</h3><p>RabbitMQ 的官方也推出了一个插件，原生支持延迟消息的功能。该插件的原理是设计了一种支持延迟消息功能的交换机，当消息投递到交换机后可以暂存一定时间，到期后再投递到队列</p><h3 id="取消超时订单">取消超时订单</h3><p>设置 30 min 后检测订单支付状态存在两个问题：</p><ul><li>如果并发较高，30 min 后可能堆积消息过多</li><li>大多数订单很快就会支付，却需要再 MQ 内等待 30 min，浪费资源</li></ul><p>解决：把一个长的延迟消息分成多个短的延迟消息，比如 10s, 10s, 10s, 15s, 15s, …, 10min，这个延迟序列中前面的时间较短，后面的时间较长，从而保证大部分的消息可以在前面较短的时间内就被处理完</p><p><a href="/images/blog/rabbitmq/advance/pay-status.png"></a></p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://226wyj.github.io" target="_blank">Wu, Yuejiang</a></li><li>本文链接：<a href="https://226wyj.github.io/2024/01/04/RabbitMQ-learn-advance/" target="_blank">https://226wyj.github.io/2024/01/04/RabbitMQ-learn-advance/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/226wyj/226wyj.github.io@master/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/2024/01/04/RabbitMQ-learn-advance/', clientID: '816a74632f6a9e1d895c', clientSecret: '69da216c45ee48df2f0e92506cf044cbc001ef2b', repo: 'blog-comment', owner: '226wyj', admin: ['226wyj'], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/226wyj/226wyj.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://226wyj.github.io/assets/search_data.json?v=1704574356', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/226wyj/226wyj.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2015 <span title="Wu, Yuejiang">Wu, Yuejiang</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/226wyj/226wyj.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://226wyj.github.io/" title="Home" target="">Home</a></li><li> <a href="https://226wyj.github.io/categories/" title="Categories" target="">Categories</a></li><li> <a href="https://226wyj.github.io/wiki/" title="Wiki" target="">Wiki</a></li><li> <a href="https://226wyj.github.io/links/" title="Link" target="">Link</a></li><li> <a href="https://226wyj.github.io/about/" title="About" target="">About</a></li><li><a href="https://226wyj.github.io/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/gh/226wyj/226wyj.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-80669434-1', 'auto'); ga('send', 'pageview'); </script></div></body></html>
